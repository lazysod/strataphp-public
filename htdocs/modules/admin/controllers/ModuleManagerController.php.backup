<?php
namespace App\Modules\Admin\Controllers;

/**
 * Module Manager Controller
 * 
 * Handles module management interface including enabling/disabling modules
 * and setting the default module
 */
class ModuleManagerController {
    
    /**
     * Display module management interface
     * 
     * @return void
     */
    public function index() {
        try {
            global $config;
            
            // Handle form submission first
            if ($_SERVER['REQUEST_METHOD'] === 'POST') {
                $this->handleFormSubmission();
                return;
            }
            
            // Scan filesystem for all modules and merge with config
            $modules = $this->scanModules($config);
            
            // Include the view directly with variables available
            include __DIR__ . '/../views/module_manager_simple.php';
        } catch (\Exception $e) {
            error_log("Error loading module manager: " . $e->getMessage());
            http_response_code(500);
            echo '<h1>Error loading module manager</h1>';
        }
    }
    
    /**
     * Handle form submission directly in the index method
     */
    private function handleFormSubmission() {
        try {
            global $config;
            $enabled = $_POST['enabled'] ?? [];
            
            // Remove duplicates that might come from multiple form views
            $enabled = array_unique($enabled);
            
            // Get all modules from filesystem scan
            $allModules = $this->scanModules($config);
            
            // Initialize modules array if not exists
            if (!isset($config['modules'])) {
                $config['modules'] = [];
            }
            
            // Update all modules - IMPORTANT: Set ALL modules, not just enabled ones
            foreach ($allModules as $modName => $modInfo) {
                // Admin and home modules are always enabled
                if ($modName === 'admin' || $modName === 'home') {
                    $config['modules'][$modName]['enabled'] = true;
                } else {
                    // A module is enabled ONLY if it's in the $enabled array
                    // If checkbox is unchecked, it won't be in the array, so it gets disabled
                    $isEnabled = in_array($modName, $enabled);
                    $config['modules'][$modName]['enabled'] = $isEnabled;
                }
                
                // Preserve or set suitable_as_default flag
                if (!isset($config['modules'][$modName]['suitable_as_default'])) {
                    $config['modules'][$modName]['suitable_as_default'] = false;
                }
            }
            
            // Save default module selection
            if (isset($_POST['default_module']) && in_array($_POST['default_module'], $enabled)) {
                $config['default_module'] = $_POST['default_module'];
            }
            
            $configPath = __DIR__ . '/../../../app/config.php';
            $configExport = var_export($config, true);
            
            // Security: Validate config path and backup original
            if (!$this->isSecureConfigPath($configPath)) {
                throw new \Exception("Invalid configuration path");
            }
            
            if (!$this->secureConfigWrite($configPath, "<?php\nreturn $configExport;")) {
                throw new \Exception("Failed to write configuration file");
            }
            
            $_SESSION['success'] = 'Module configuration updated successfully.';
            header('Location: /admin/modules');
            exit;
        } catch (\Exception $e) {
            error_log("Error updating module configuration: " . $e->getMessage());
            $_SESSION['error'] = 'Error updating module configuration: ' . $e->getMessage();
            header('Location: /admin/modules');
            exit;
        }
    }
    
    /**
     * Scan filesystem for all modules and merge with config data
     */
    private function scanModules($config) {
        $modules = [];
        $modulesPath = $_SERVER['DOCUMENT_ROOT'] . '/modules';
        
        if (!is_dir($modulesPath)) {
            return isset($config['modules']) ? $config['modules'] : [];
        }
        
        // Scan filesystem for module directories
        $moduleDirectories = array_filter(glob($modulesPath . '/*'), 'is_dir');
        
        foreach ($moduleDirectories as $moduleDir) {
            $moduleName = basename($moduleDir);
            $moduleJsonPath = $moduleDir . '/module.json';
            
            // Skip if no module.json exists
            if (!file_exists($moduleJsonPath)) {
                continue;
            }
            
            // Start with config data if exists
            $moduleData = isset($config['modules'][$moduleName]) ? $config['modules'][$moduleName] : [];
            
            // Set defaults for modules not in config
            if (!isset($moduleData['enabled'])) {
                $moduleData['enabled'] = false;
            }
            if (!isset($moduleData['suitable_as_default'])) {
                $moduleData['suitable_as_default'] = false;
            }
            
            $modules[$moduleName] = $moduleData;
        }
        
        return $modules;
    }

    /**
     * Security: Validate configuration file path
     */
    private function isSecureConfigPath($configPath)
    {
        $realPath = realpath(dirname($configPath));
        $expectedPath = realpath(__DIR__ . '/../../../app');
        
        if ($realPath === false || $expectedPath === false) {
            return false;
        }
        
        // Ensure we're only writing to the app directory
        return $realPath === $expectedPath && basename($configPath) === 'config.php';
    }
    
    /**
     * Security: Safe configuration file writing with backup
     */
    private function secureConfigWrite($configPath, $content)
    {
        // Validate content is PHP
        if (!str_starts_with($content, '<?php')) {
            return false;
        }
        
        // Create backup
        $backupPath = $configPath . '.backup.' . time();
        if (file_exists($configPath)) {
            copy($configPath, $backupPath);
        }
        
        // Write new config
        $result = file_put_contents($configPath, $content, LOCK_EX);
        
        // Clean up old backups (keep only last 5)
        $this->cleanupConfigBackups(dirname($configPath));
        
        return $result !== false;
    }
    
    /**
     * Clean up old configuration backups
     */
    private function cleanupConfigBackups($configDir)
    {
        $backups = glob($configDir . '/config.php.backup.*');
        if (count($backups) > 5) {
            rsort($backups); // Sort by filename (timestamp)
            $toDelete = array_slice($backups, 5);
            foreach ($toDelete as $backup) {
                unlink($backup);
            }
        }
    }
    
    /**
     * Delete a module with safety checks
     */
    public function delete($moduleName = null)
    {
        try {
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                $this->jsonResponse(['success' => false, 'message' => 'Invalid request method']);
                return;
            }
            
            // Get module name from route parameter or POST data (for backward compatibility)
            if (empty($moduleName)) {
                $moduleName = $_POST['module_name'] ?? '';
            }
            
            // Validate module name
            if (empty($moduleName)) {
                $this->jsonResponse(['success' => false, 'message' => 'Module name is required']);
                return;
            }
            
            // For safety, we still want user confirmation, but we'll get it from the frontend
            // The frontend should have already validated the user typed the correct name
            
            // Check if module can be deleted
            $protectionCheck = $this->checkModuleProtection($moduleName);
            if (!$protectionCheck['can_delete']) {
                $this->jsonResponse(['success' => false, 'message' => $protectionCheck['reason']]);
                return;
            }
            
            // Create backup before deletion
            $backupPath = $this->createModuleBackup($moduleName);
            
                        // Perform the deletion
            $result = $this->performModuleDeletion($moduleName, false); // Default to not keeping data
            
            if ($result['success']) {
                $this->jsonResponse([
                    'success' => true, 
                    'message' => 'Module deleted successfully',
                    'backup_path' => $backupPath
                ]);
            } else {
                $this->jsonResponse(['success' => false, 'message' => $result['message']]);
            }
            
        } catch (\Exception $e) {
            error_log("Module deletion error: " . $e->getMessage());
            $this->jsonResponse(['success' => false, 'message' => 'An error occurred during deletion']);
        }
    }
    
    /**
     * Check if a module can be safely deleted
     */
    private function checkModuleProtection($moduleName)
    {
        global $config;
        
        // System modules that cannot be deleted
        $systemModules = ['admin', 'user'];
        if (in_array($moduleName, $systemModules)) {
            return [
                'can_delete' => false,
                'reason' => 'Cannot delete system module: ' . $moduleName
            ];
        }
        
        // Check if it's the default module
        $defaultModule = $config['default_module'] ?? '';
        if ($moduleName === $defaultModule) {
            return [
                'can_delete' => false,
                'reason' => 'Cannot delete the default module. Change default module first.'
            ];
        }
        
        // Check if other modules depend on this one
        $dependencies = $this->checkModuleDependencies($moduleName);
        if (!empty($dependencies)) {
            return [
                'can_delete' => false,
                'reason' => 'Cannot delete module. Required by: ' . implode(', ', $dependencies)
            ];
        }
        
        // Check if module exists
        $moduleDir = dirname(__DIR__, 2) . '/' . $moduleName;
        if (!is_dir($moduleDir)) {
            return [
                'can_delete' => false,
                'reason' => 'Module directory does not exist'
            ];
        }
        
        return ['can_delete' => true, 'reason' => ''];
    }
    
    /**
     * Check which modules depend on the given module
     */
    private function checkModuleDependencies($moduleName)
    {
        $dependentModules = [];
        $modulesDir = dirname(__DIR__, 2);
        
        if (!is_dir($modulesDir)) {
            return $dependentModules;
        }
        
        $dirs = scandir($modulesDir);
        foreach ($dirs as $dir) {
            if ($dir === '.' || $dir === '..' || $dir === $moduleName) continue;
            
            $moduleIndexPath = $modulesDir . '/' . $dir . '/index.php';
            if (file_exists($moduleIndexPath)) {
                $moduleData = include $moduleIndexPath;
                $dependencies = $moduleData['dependencies'] ?? [];
                
                if (in_array($moduleName, $dependencies)) {
                    $dependentModules[] = $dir;
                }
            }
        }
        
        return $dependentModules;
    }
    
    /**
     * Create a backup of the module before deletion
     */
    private function createModuleBackup($moduleName)
    {
        $moduleDir = dirname(__DIR__, 2) . '/' . $moduleName;
        $backupDir = dirname(__DIR__, 4) . '/storage/backups/modules';
        
        // Create backup directory if it doesn't exist
        if (!is_dir($backupDir)) {
            mkdir($backupDir, 0755, true);
        }
        
        $timestamp = date('Y-m-d_H-i-s');
        $backupPath = $backupDir . '/' . $moduleName . '_' . $timestamp . '.zip';
        
        // Create ZIP backup
        $zip = new \ZipArchive();
        if ($zip->open($backupPath, \ZipArchive::CREATE) === TRUE) {
            $this->addDirectoryToZip($zip, $moduleDir, $moduleName);
            $zip->close();
        }
        
        return $backupPath;
    }
    
    /**
     * Recursively add directory to ZIP archive
     */
    private function addDirectoryToZip($zip, $dir, $base = '')
    {
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($dir, \RecursiveDirectoryIterator::SKIP_DOTS),
            \RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $file) {
            $relativePath = str_replace($dir . '/', '', $file->getRealPath());
            if ($file->isDir()) {
                $zip->addEmptyDir($base . '/' . $relativePath);
            } else {
                $zip->addFile($file->getRealPath(), $base . '/' . $relativePath);
            }
        }
    }
    
    /**
     * Perform the actual module deletion
     */
    private function performModuleDeletion($moduleName, $keepData = false)
    {
        try {
            global $config;
            
            // 1. Remove from config
            if (isset($config['modules'][$moduleName])) {
                unset($config['modules'][$moduleName]);
                
                // Save updated config
                $configPath = dirname(__DIR__, 3) . '/app/config.php';
                $configContent = "<?php\nreturn " . var_export($config, true) . ";\n";
                file_put_contents($configPath, $configContent);
            }
            
            // 2. Remove from composer.json
            $this->removeFromComposer($moduleName);
            
            // 3. Remove module directory
            $moduleDir = dirname(__DIR__, 2) . '/' . $moduleName;
            if (is_dir($moduleDir)) {
                $this->removeDirectory($moduleDir);
            }
            
            // 4. Optionally drop database tables
            if (!$keepData) {
                $this->dropModuleTables($moduleName);
            }
            
            return ['success' => true, 'message' => 'Module deleted successfully'];
            
        } catch (\Exception $e) {
            return ['success' => false, 'message' => 'Deletion failed: ' . $e->getMessage()];
        }
    }
    
    /**
     * Remove module from composer.json
     */
    private function removeFromComposer($moduleName)
    {
        $composerPath = dirname(__DIR__, 4) . '/composer.json';
        if (!file_exists($composerPath)) {
            return;
        }
        
        $composer = json_decode(file_get_contents($composerPath), true);
        $moduleClass = ucfirst($moduleName);
        $namespace = "App\\Modules\\{$moduleClass}\\";
        
        // Remove PSR-4 autoloading entries
        if (isset($composer['autoload']['psr-4'][$namespace . "Controllers\\"])) {
            unset($composer['autoload']['psr-4'][$namespace . "Controllers\\"]);
        }
        if (isset($composer['autoload']['psr-4'][$namespace . "Models\\"])) {
            unset($composer['autoload']['psr-4'][$namespace . "Models\\"]);
        }
        
        file_put_contents($composerPath, json_encode($composer, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES));
    }
    
    /**
     * Recursively remove directory
     */
    private function removeDirectory($dir)
    {
        if (!is_dir($dir)) {
            return;
        }
        
        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($dir, \RecursiveDirectoryIterator::SKIP_DOTS),
            \RecursiveIteratorIterator::CHILD_FIRST
        );
        
        foreach ($iterator as $file) {
            if ($file->isDir()) {
                rmdir($file->getRealPath());
            } else {
                unlink($file->getRealPath());
            }
        }
        
        rmdir($dir);
    }
    
    /**
     * Drop module-specific database tables
     */
    private function dropModuleTables($moduleName)
    {
        // This is optional and dangerous - only drop if explicitly requested
        // Implementation would depend on your database structure
        // For now, just log the intention
        error_log("Note: Database tables for module '{$moduleName}' not automatically dropped. Manual cleanup may be required.");
    }
    
    /**
     * Return JSON response
     */
    private function jsonResponse($data)
    {
        header('Content-Type: application/json');
        echo json_encode($data);
        exit;
    }
}
